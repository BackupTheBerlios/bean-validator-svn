package de.berlios.beanvalidator.validator;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.beanutils.PropertyUtils;
import org.apache.log4j.Logger;

import de.berlios.beanvalidator.formatter.FormatterRegistry;

/**
 * Core engine that provides basic methods for high-level bean-specific 
 * validators. Can be extended via the Decorator pattern (GoF).
 * @author $Author$
 * @version $Revision$
 */
public class ValidatorEngine implements Validator {
	private static Logger logger = Logger.getLogger(ValidatorEngine.class);
	private Object bean;
	private Map<String,Pattern> requiredPropertyRules;
	private Map<String,Pattern> optionalPropertyRules;
	private List<String> errors;
	private FormatterRegistry registry;
	private boolean valid;

	/**
	 * Default constructor.
	 */
	public ValidatorEngine() {
		requiredPropertyRules = new HashMap<String,Pattern>();
		optionalPropertyRules = new HashMap<String,Pattern>();
		errors                = new ArrayList<String>();
		registry              = FormatterRegistry.getInstance();
		valid                 = false;
	}

	/**
	 * Constructor.
	 * @param bean - JavaBean-compliant object to be validated
	 */
	public ValidatorEngine(Object bean) {
		this();
		setBean(bean);
	}

	/**
	 * Set bean to be validated.
	 * @param bean - JavaBean-compliant object to be validated
	 */
	public void setBean(Object bean) {
		logger.debug("Validating bean of type: " + bean.getClass().getName());
		this.bean = bean;
	}

	/**
	 * Get list of errors generated by validation failures.
	 * @return List of validation errors
	 */
	public List<String> getErrors() {
		logger.debug("Returning list of " + errors.size() + " errors");
		return errors;
	}

	/**
	 * Determine if bean is valid or not.
	 * @return Validation status (true = valid, false = invalid)
	 */
	public boolean isValid() {
		validate();
		return valid;
	}

	/**
	 * Add validation rule for required bean property. Required properties 
	 * cannot be null.
	 * @param propertyName - name of required property
	 * @param propertyRule - validation rule for bean property
	 */
	public void addRequiredPropertyRule(String propertyName, Pattern propertyRule) {
		requiredPropertyRules.put(propertyName, propertyRule);
	}

	/**
	 * Add validation rule for required bean property. Required properties 
	 * cannot be null.
	 * @param propertyName - name of required property
	 * @param propertyRule - validation rule for bean property
	 */
	public void addRequiredPropertyRule(String propertyName, String propertyRule) {
		addRequiredPropertyRule(propertyName, Pattern.compile(propertyRule));
	}

	/**
	 * Add validation rule for optional bean property. Optional properties
	 * can be null.
	 * @param propertyName - name of optional property
	 * @param propertyRule - validation rule for bean property
	 */
	public void addOptionalPropertyRule(String propertyName, Pattern propertyRule) {
		optionalPropertyRules.put(propertyName, propertyRule);
	}

	/**
	 * Add validation rule for optional bean property. Optional properties
	 * can be null.
	 * @param propertyName - name of optional property
	 * @param propertyRule - validation rule for bean property
	 */
	public void addOptionalPropertyRule(String propertyName, String propertyRule) {
		addOptionalPropertyRule(propertyName, Pattern.compile(propertyRule));
	}

	/**
	 * Add validation rule for bean property.
	 * @param propertyName - name of property
	 * @param propertyRule - validation rule for bean property
	 * @param isRequired - is property required? (true = required, false = optional)
	 */
	public void addPropertyRule(String propertyName, Pattern propertyRule, boolean isRequired) {
		if (isRequired) {
			addRequiredPropertyRule(propertyName, propertyRule);
		}
		else {
			addOptionalPropertyRule(propertyName, propertyRule);
		}
	}

	/**
	 * Add validation rule for bean property.
	 * @param propertyName - name of property
	 * @param propertyRule - validation rule for bean property
	 * @param isRequired - is property required? (true = required, false = optional)
	 */
	public void addPropertyRule(String propertyName, String propertyRule, boolean isRequired) {
		if (isRequired) {
			addRequiredPropertyRule(propertyName, propertyRule);
		}
		else {
			addOptionalPropertyRule(propertyName, propertyRule);
		}
	}

	/**
	 * Run validation rules against bean properties and collect failures
	 * and resulting error messages.
	 */
	protected void validate() {
		// Reset error list.
		errors = new ArrayList<String>();
		
		int failures = 0;
		
		// 1. Run rules against required bean properties.
		failures += validateRequiredProperties();
		
		// 2. Run rules against optional bean properties.
		failures += validateOptionalProperties();
		
		// 3. Valid if 0 failures were encountered.
		valid = (failures == 0) ? true : false;
	}

	/**
	 * Run validation rules against required bean properties and collect 
	 * failures.
	 * @return Number of validation failures
	 */
	protected int validateRequiredProperties() {
		int reqFailures = 0;
		
		Iterator reqPropNames = requiredPropertyRules.keySet().iterator();
		while (reqPropNames.hasNext()) {
			String  propName  = (String)reqPropNames.next();
			Pattern propRule  = requiredPropertyRules.get(propName);
			Object  propValue = null;
			
			try {
				propValue = PropertyUtils.getProperty(bean, propName);
			}
			catch (Exception e) {
				logger.debug("Failed to retrieve property: " + propName, e);
				errors.add(e.getMessage());
				reqFailures += 1;
				continue;
			}
			
			if (propValue == null) {
				errors.add("Required property " + propName + " is null");
				reqFailures += 1;
				continue;
			}
			
			if (propValue instanceof Validateable) {
				Validateable validateable = (Validateable)propValue;
				if (!validateable.getValidator().isValid()) {
					errors.addAll(validateable.getValidator().getErrors());
					reqFailures += 1;
					continue;
				}
			}
			
			if (!(propValue instanceof String)) {
				if (registry.hasFormatter(propValue.getClass())) {
					de.berlios.beanvalidator.formatter.Formatter formatter = 
						registry.getFormatter(propValue.getClass());
					propValue = formatter.format(propValue);
				}
				else {
					errors.add("Cannot format " + propName + " to validate");
					reqFailures += 1;
					continue;
				}
				
			}
			
			Matcher matcher = propRule.matcher((String)propValue);
			if (!matcher.matches()) {
				errors.add("Value of " + propName + " is invalid");
				reqFailures += 1;
			}
		}
		
		return reqFailures;
	}

	/**
	 * Run validation rules against optional bean properties and collect 
	 * failures.
	 * @return Number of validation failures
	 */
	protected int validateOptionalProperties() {
		int optFailures = 0;
		
		Iterator optPropNames = optionalPropertyRules.keySet().iterator();
		while (optPropNames.hasNext()) {
			String  propName  = (String)optPropNames.next();
			Pattern propRule  = optionalPropertyRules.get(propName);
			Object  propValue = null;
			
			try {
				propValue = PropertyUtils.getProperty(bean, propName);
			}
			catch (Exception e) {
				logger.debug("Failed to retrieve property: " + propName, e);
				errors.add(e.getMessage());
				optFailures += 1;
				continue;
			}
			
			if (propValue == null) {
				continue;
			}
			
			if (propValue instanceof Validateable) {
				Validateable validateable = (Validateable)propValue;
				if (!validateable.getValidator().isValid()) {
					errors.addAll(validateable.getValidator().getErrors());
					optFailures += 1;
					continue;
				}
			}
			
			if (!(propValue instanceof String)) {
				if (registry.hasFormatter(propValue.getClass())) {
					de.berlios.beanvalidator.formatter.Formatter formatter = 
						registry.getFormatter(propValue.getClass());
					propValue = formatter.format(propValue);
				}
				else {
					errors.add("Cannot format " + propName + " to validate");
					optFailures += 1;
					continue;
				}
			}
			
			Matcher matcher = propRule.matcher((String)propValue);
			if (!matcher.matches()) {
				errors.add("Value of " + propName + " is invalid");
				optFailures += 1;
			}
		}
		
		return optFailures;
	}
}
